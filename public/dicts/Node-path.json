[
  { "name": "fs.Dir", "trans": ["类，表示目录流。创建者fs.opendir()，fs.opendirSync()或 fsPromises.opendir()。"] },
  { "name": "fs.Dirent", "trans": ["类，通过从读取返回的目录条目的表示形式，可以是目录中的文件或子目录fs.Dir。目录条目是文件名和文件类型对的组合。"] },
  { "name": "fs.FSWatcher", "trans": ["类，成功调用fs.watch()方法将返回一个新fs.FSWatcher 对象。只要修改了特定的监视文件，所有fs.FSWatcher对象都会发出一个'change'事件。"] },
  { "name": "fs.StatWatcher", "trans": ["类，成功调用fs.watchFile()方法将返回一个新fs.StatWatcher 对象。  "] },
  { "name": "fs.ReadStream", "trans": ["类，使用的实例fs.ReadStream创建并返回 fs.createReadStream()。"] },
  { "name": "fs.Stats", "trans": ["类，fs.Stats对象提供有关文件的信息。"] },
  { "name": "fs.WriteStream", "trans": ["类，使用的实例fs.WriteStream创建并返回 fs.createWriteStream()。"] },
  { "name": "fs.access(path[, mode], callback)", "trans": ["测试用户对所指定的文件或目录的权限path。该mode参数是一个可选整数，它指定要执行的可访问性检查。检查“文件访问常量”中可能的值mode。可以创建由两个或多个值（例如fs.constants.W_OK | fs.constants.R_OK）的按位或组成的掩码。    "] },
  { "name": "fs.accessSync(path[, mode])", "trans": ["同步测试用户对所指定的文件或目录的权限path。该mode参数是一个可选整数，它指定要执行的可访问性检查。"] },
  { "name": "fs.appendFile(path, data[, options], callback)", "trans": ["异步将数据追加到文件，如果该文件尚不存在，则创建该文件。data可以是字符串或Buffer。    "] },
  { "name": "fs.appendFileSync(path, data[, options])", "trans": ["将数据同步追加到文件，如果该文件尚不存在，则创建该文件。data可以是字符串或Buffer。"] },
  { "name": "fs.chmod(path, mode, callback)", "trans": ["异步更改文件的权限"] },
  { "name": "fs.chmodSync(path, mode)", "trans": ["同步更改文件的权限"] },
  { "name": "fs.chown(path, uid, gid, callback)", "trans": ["异步更改文件的所有者和组。"] },
  { "name": "fs.chownSync(path, uid, gid)", "trans": ["同步更改文件的所有者和组。"] },
  { "name": "fs.close(fd, callback)", "trans": ["异步关闭文件"] },
  { "name": "fs.closeSync(fd)", "trans": ["同步关闭文件"] },
  { "name": "fs.constants", "trans": ["返回一个包含文件系统操作常用常量的对象。当前定义的特定常数在FS常数中进行了描述 。"] },
  { "name": "fs.copyFile(src, dest[, mode], callback)", "trans": ["异步复制src到dest。默认情况下，dest如果已经存在，则被覆盖。除可能的异常外，没有其他任何参数被赋予回调函数。Node.js不保证复制操作的原子性。如果在打开目标文件进行写入后发生错误，Node.js将尝试删除目标。mode是一个可选整数，它指定复制操作的行为。可以创建由两个或多个值（例如fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE）的按位或组成的掩码 。"] },
  { "name": "fs.copyFileSync(src, dest[, mode])", "trans": ["同步复制src到dest。默认情况下，dest如果已经存在，则被覆盖。返回undefined。Node.js不保证复制操作的原子性。如果在打开目标文件进行写入后发生错误，Node.js将尝试删除目标。mode是一个可选整数，它指定复制操作的行为。可以创建由两个或多个值（例如fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE）的按位或组成的掩码 。"] },
  { "name": "fs.createReadStream(path[, options])", "trans": ["创建可读流，此方法返回的流具有 64 kb 的默认 highWaterMark"] },
  { "name": "fs.createWriteStream(path[, options])", "trans": ["创建可写流"] },
  { "name": "fs.exists(path, callback)", "trans": ["弃用: 改为使用 fs.stat() 或 fs.access()。"] },
  { "name": "fs.existsSync(path)", "trans": ["如果路径存在，则返回 true，否则返回 false。"] },
  { "name": "fs.fchmod(fd, mode, callback)", "trans": ["异步的fchmod(2), 会依参数 mode 权限来更改参数fildes所指文件的权限"] },
  { "name": "fs.fchmodSync(fd, mode)", "trans": ["同步fchmod(2), 会依参数mode权限来更改参数fildes所指文件的权限。  "] },
  { "name": "fs.fchown(fd, uid, gid, callback)", "trans": ["异步的fchown(2), 会将参数fd指定文件的所有者变更为参数owner代表的用户，而将该文件的组变更为参数group组"] },
  { "name": "fs.fchownSync(fd, uid, gid)", "trans": ["同步的fchown(2), 会将参数fd指定文件的所有者变更为参数owner代表的用户，而将该文件的组变更为参数group组"] },
  { "name": "fs.fdatasync(fd, callback)", "trans": ["异步的fdatasync(2), 用来刷新数据到磁盘"] },
  { "name": "fs.fdatasyncSync(fd)", "trans": [] },
  { "name": "fs.fstat(fd[, options], callback)", "trans": [] },
  { "name": "fs.fstatSync(fd[, options])", "trans": [] },
  { "name": "fs.fsync(fd, callback)", "trans": [] },
  { "name": "fs.fsyncSync(fd)", "trans": [] },
  { "name": "fs.ftruncate(fd[, len], callback)", "trans": [] },
  { "name": "fs.ftruncateSync(fd[, len])", "trans": [] },
  { "name": "fs.futimes(fd, atime, mtime, callback)", "trans": [] },
  { "name": "fs.futimesSync(fd, atime, mtime)", "trans": [] },
  { "name": "fs.lchmod(path, mode, callback)", "trans": [] },
  { "name": "fs.lchmodSync(path, mode)", "trans": [] },
  { "name": "fs.lchown(path, uid, gid, callback)", "trans": [] },
  { "name": "fs.lchownSync(path, uid, gid)", "trans": [] },
  { "name": "fs.lutimes(path, atime, mtime, callback)", "trans": [] },
  { "name": "fs.lutimesSync(path, atime, mtime)", "trans": [] },
  { "name": "fs.link(existingPath, newPath, callback)", "trans": [] },
  { "name": "fs.linkSync(existingPath, newPath)", "trans": [] },
  { "name": "fs.lstat(path[, options], callback)", "trans": [] },
  { "name": "fs.lstatSync(path[, options])", "trans": [] },
  { "name": "fs.mkdir(path[, options], callback)", "trans": [] },
  { "name": "fs.mkdirSync(path[, options])", "trans": [] },
  { "name": "fs.mkdtemp(prefix[, options], callback)", "trans": [] },
  { "name": "fs.mkdtempSync(prefix[, options])", "trans": [] },
  { "name": "fs.open(path[, flags[, mode]], callback)", "trans": [] },
  { "name": "fs.opendir(path[, options], callback)", "trans": [] },
  { "name": "fs.opendirSync(path[, options])", "trans": [] },
  { "name": "fs.openSync(path[, flags, mode])", "trans": [] },
  { "name": "fs.read(fd, buffer, offset, length, position, callback)", "trans": [] },
  { "name": "fs.read(fd, [options,] callback)", "trans": [] },
  { "name": "fs.readdir(path[, options], callback)", "trans": [] },
  { "name": "fs.readdirSync(path[, options])", "trans": [] },
  { "name": "fs.readFile(path[, options], callback)", "trans": [] },
  { "name": "fs.readFileSync(path[, options])", "trans": [] },
  { "name": "fs.readlink(path[, options], callback)", "trans": [] },
  { "name": "fs.readlinkSync(path[, options])", "trans": [] },
  { "name": "fs.readSync(fd, buffer, offset, length, position)", "trans": [] },
  { "name": "fs.readSync(fd, buffer, [options])", "trans": [] },
  { "name": "fs.readv(fd, buffers[, position], callback)", "trans": [] },
  { "name": "fs.readvSync(fd, buffers[, position])", "trans": [] },
  { "name": "fs.realpath(path[, options], callback)", "trans": [] },
  { "name": "fs.realpath.native(path[, options], callback)", "trans": [] },
  { "name": "fs.realpathSync(path[, options])", "trans": [] },
  { "name": "fs.realpathSync.native(path[, options])", "trans": [] },
  { "name": "fs.rename(oldPath, newPath, callback)", "trans": [] },
  { "name": "fs.renameSync(oldPath, newPath)", "trans": [] },
  { "name": "fs.rmdir(path[, options], callback)", "trans": [] },
  { "name": "fs.rmdirSync(path[, options])", "trans": [] },
  { "name": "fs.rm(path[, options], callback)", "trans": [] },
  { "name": "fs.rmSync(path[, options])", "trans": [] },
  { "name": "fs.stat(path[, options], callback)", "trans": [] },
  { "name": "fs.statSync(path[, options])", "trans": [] },
  { "name": "fs.symlink(target, path[, type], callback)", "trans": [] },
  { "name": "fs.symlinkSync(target, path[, type])", "trans": [] },
  { "name": "fs.truncate(path[, len], callback)", "trans": [] },
  { "name": "fs.truncateSync(path[, len])", "trans": [] },
  { "name": "fs.unlink(path, callback)", "trans": [] },
  { "name": "fs.unlinkSync(path)", "trans": [] },
  { "name": "fs.unwatchFile(filename[, listener])", "trans": [] },
  { "name": "fs.utimes(path, atime, mtime, callback)", "trans": [] },
  { "name": "fs.utimesSync(path, atime, mtime)", "trans": [] },
  { "name": "fs.watch(filename[, options][, listener])", "trans": [] },
  { "name": "fs.watchFile(filename[, options], listener)", "trans": [] },
  { "name": "fs.write(fd, buffer[, offset[, length[, position]]], callback)", "trans": [] },
  { "name": "fs.write(fd, string[, position[, encoding]], callback)", "trans": [] },
  { "name": "fs.writeFile(file, data[, options], callback)", "trans": [] },
  { "name": "fs.writeFileSync(file, data[, options])", "trans": [] },
  { "name": "fs.writeSync(fd, buffer[, offset[, length[, position]]])", "trans": [] },
  { "name": "fs.writeSync(fd, string[, position[, encoding]])", "trans": [] },
  { "name": "fs.writev(fd, buffers[, position], callback)", "trans": [] },
  { "name": "fs.writevSync(fd, buffers[, position])", "trans": [] },
]
